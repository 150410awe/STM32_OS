2026.2.22.20.08
我和external_device_memory_distribution.h又斗了一会.
现在完全是编译时了, 主要是更加安全,可读性更强
any int 不可以直接引用
general::device::external_device_memory[external_device_type].start
general::device::external_device_memory[static_cast<general::device::external_device_type>(i)].contains(address_value)
const auto c1cc = general::device::external_device_memory[general::device::external_device_type::null];
emmmmm, 尽管我写的难受, 但是使用还是很好
0.00.02 小补丁, FSMC_device_memory, external_device_memory 完全编译期. 增加了安全性和可读性
2026.2.22.17.55
DS:
用你的 gpio_address 去操作寄存器。
你会发现自己设计的类型用起来有多顺手——比如：
cpp
gpio_addr odr { 0x40020014 };
odr = 0x01;  // 点亮 LED
编译器会阻止你把 sram_addr 赋值给 odr，这种安全感在裸机上很珍贵。
...
有感, 不知道为什么想到,emmmmm, 直接看代码
    constexpr max_int_t null_address_value = 0x100000000;// null_address_value - 默认空地址值, 为 null_address 指向的地址值, 一般改不了
    constexpr int_interval null_address_interval {null_address_value,null_address_value};
    // 前向声明, 尽管无法完全 constexpr, 但是一个引用也算是零成本了
    static constexpr std::array<int_interval, static_cast<size_t>(external_device_type::MAX_VAL)> init_external_device_memory();
    static constexpr std::array<int_interval, static_cast<size_t>(FSMC_device_type::MAX_VAL)> init_FSMC_device_memory();
    
    // 使用前向声明的函数初始化
    const inline ...& external_device_memory{ init_external_device_memory() };
    const inline  ...& FSMC_device_memory { init_FSMC_device_memory() };

external_device_memory[static_cast<size_t>(external_device_type::null)] = memory::distribution::null_address_interval;
FSMC_device_memory[static_cast<size_t>(FSMC_device_type::null)] = memory::distribution::null_address_interval;
支持null
struct peripheral_address : address<peripheral_address, block::peripheral_area> {
    constexpr peripheral_address() = default;
    constexpr peripheral_address(const general::device::external_device_type set_device_type) : external_device_type(set_device_type) {
        address_value = general::device::external_device_memory[static_cast<size_t>(external_device_type)].start;
    }
    peripheral_address& operator=(const general::device::external_device_type set_device_type) {
        external_device_type = set_device_type;
        address_value = general::device::external_device_memory[static_cast<size_t>(external_device_type)].start;
        return *this;
    }
    constexpr peripheral_address& operator+=(const peripheral_address set_address) = delete;
    constexpr peripheral_address operator+(const peripheral_address set_address) = delete;
    general::device::external_device_type external_device_type = general::device::external_device_type::null;
    ...
};
struct FSMC_address : address<FSMC_address, block::FSMC> {
    constexpr FSMC_address()  = default;
    constexpr FSMC_address(const general::device::FSMC_device_type set_device_type) : FSMC_device_type(set_device_type) {
        address_value = general::device::FSMC_device_memory[static_cast<size_t>(FSMC_device_type)].start;
    }
    FSMC_address& operator=(const general::device::FSMC_device_type set_device_type ) {
        FSMC_device_type = set_device_type;
        address_value = general::device::FSMC_device_memory[static_cast<size_t>(FSMC_device_type)].start;
        return *this;
    }
    constexpr FSMC_address& operator+=(const FSMC_address set_address) = delete;
    constexpr FSMC_address operator+(const FSMC_address set_address) = delete;
    ....
};

    FSMC_address f1{};
    FSMC_address f2{f1};
    //FSMC_address f3{100}; error
    FSMC_address f4{general::device::FSMC_device_type::FSMC_NAND2};
    FSMC_address f5{general::device::FSMC_device_type::null};

    //f2 = FSMC_address{1000}; error
    //f2 = &aa_value; error
    // 因为general::device::FSMC_device_type 不是 constexpr 所以不可以, 这是编绎器的问题, 不星我的问题
    //constexpr FSMC_address f6{general::device::FSMC_device_type::FSMC_NAND2};

    //f1 += f2; error
    f1 = f2;
    // f1 + f2; error

    peripheral_address p1{};
    peripheral_address p2 = p1;
    // peripheral_address p3{general::device::FSMC_device_type::FSMC_NAND1} error
    peripheral_address p4{general::device::external_device_type::ADC1};
    peripheral_address p5{general::device::external_device_type::null};
    //...
这增加了安全性. 还有我不用记内存了. 直接general::device::external_device_type::....
简单～
对了. null_address 也是原规上不可以修改 address_value
// NULL 不可以修改
    constexpr null_address& operator=(max_int_t set_address) = delete;
    constexpr null_address& operator+=(const max_int_t set_address) = delete;
    constexpr null_address operator+(const max_int_t set_address) const = delete;
    constexpr null_address operator+(const null_address set_address) const = delete;
......
对的.就这样了. 这是一个小补丁
0.00.02 小补丁, 地址类型加强, 增加了安全性和简单性
已更改 8 个文件, 179 行插入(+), 45 行删除(-)
2026.2.22.16.35
我终于写完了外设类型与外设地址, 我使用了 CRTP emmmm,
好吧, 为了安全性,他更复杂了.
还好使用起来比较无脑, 看着对 constexpr 的支持好像也没问题
他可能更安全了, any int 不可以对他 operator=
code_address c112{100};
c112 = 1000; error
max_int_t aa_value = 100;
    aa = &aa_value;
auto aa = a2 + code_address{100};
    auto bb = a2 + aa;
    auto cc = a2 += code_address{10};
    auto dd = aa = code_address{10};
    constexpr code_address c1{1000};
    constexpr code_address c2{c1};
    constexpr auto c3 = c1 + c2;
    constexpr code_address c4 = c3;
    constexpr null_address c13{};
constexpr address_t operator+(const address_t set_address)
constexpr address_t& operator+=(const address_t set_address)
address_t& operator=(max_int_t* set_address)
这使得类型更安全. 但是我心还是没底.
我在想有没有必须写不同类型地址的转换. emmmmm, 后面可能去掉.
因为他有点不安全.
if (!update() || !check_address()) {
    address_value = null_address_value;
    // error...
}
constexpr bool check_address() const {
    return static_cast<const address_t*>(this)->check_address();
}
constexpr bool update() {
    return static_cast<address_t*>(this)->update();
}
这个, 应该是先update()在check_address(), 应该不会有问题.
我为了防止循环引用,拆了address_struct.h 分对应的几个类型的文件.
原则上 struct address 不可以直接写.
这几个类型地址原则上完全不是一会事.
// 检查外部设备内存是否包含该地址
        const auto& external_device_memory = general::device::external_device_memory[static_cast<size_t>(external_device_type)];
        if (!external_device_memory.contains(address_value))
            return false;
看着还不错.
但是 general::device::external_device_memory 不知道为啥不可以加 constexpr . 非常弱智.
0.00.02 外设类型,地址. 地址类型细分,加强
已更改 18 个文件, 693 行插入(+), 523 行删除(-)
2026.2.21.20.21
增加了对 clangd 的支持. 
增加了
general::memory::distribution::address::check_address()
检查地址.
去除了
update_block_type
整合到check_address
有地址块类型检查和该块类型的地址范围检查, 保证地址的合法性, 可以防止地址指向越界和保留区域
--20.59
好拉, 现在这个0.00.01也算干完了.
下面是什么?
好又不好的是这个项目不会有终端和硬盘. 这实现起来会更简单.
可以写
cctype,time,utime,Imn_enum_struct_bit_mask,variadic
emmmmm,我就会个x64,arm汇编我是不会的.
所以我直接封装一下吧.
cctype,time,utime std都有
我直接封装
variadic lmn_enum_struct_bit_mask 我copy一下
okk, 那这std就这样完了.
哎呀这个, cctype,time,utime直接用std的把,我不写了.
variadic lmn_enum_struct_bit_mask copy 过来...
我写屁. variadic 问题太多了. 还是直接用库吧, 我是无语.
我可不造一个va_start出来.
引入 lmn_enum_struct_bit_mask 
--23.22
0.00.02 增加了 general::memory::distribution::address::check_address(), update_block_type 整合到check_address, 引入 lmn_enum_struct_bit_mask
已更改 9 个文件, 312 行插入(+), 89 行删除(-)
妈的我终于配置好了这个clangd 的傻逼格式化, 无语, 怎么地还都不行
2026.2.21.11.45
哦1145...

我当然想学点嵌入式，但是at89c51 和那个2b ide还有那个无聊的课程让我一点都不想学，
说明书我看着想死。我就想可以这样。卖个性能强点，现代的板子，为他定制做个os，我去这太好了，
因为这样我就可以了解这个板子，学习他，还可以为他实现一些功能，那些功能什么定时器，时间，led，
都会用到。这不都是那2b课程会有的吗，还可以是一个os实现的实战。我去，回去我就想着卖一个我喜欢的板子玩，
只要别把我电死了
哦，我为什么要把重构收尾？！我差点就到了我关心的地方。好吧，
我对os的组成也有了个大概了解。尽管我已经忘了太多。但是我知道可能要有内存，
进程，终端，文件，重定位，权限emmmm什么，我知道他们的大概构成和一些函数。。。
emmm好吧，我都忘了。嘿嘿~
嗯~，也可以，这个嵌入式os应该更好玩。
-- 2026.2.19.22.19 日记
所以我找到了更好玩的东西. 我己经写完了内存分布参数和一些基础类型.
还有 address 类型, 我觉得他还不错
还有你发现有一个叫internal的文件夹.
为什么会有他???
因为这个项目(我)的设计原则之一就是 内部复杂外部简单
这个项目(我)的设计原则只有二个
内部复杂外部简单, 代码即文档.
所以我会有一个 type.h 一个类型定义集合.

using namespace general::type;
using general::memory::distribution::null_address;
using general::memory::distribution::code_address;
using general::memory::distribution::sram_address;
using general::memory::distribution::peripheral_address;
using general::memory::distribution::FSMC_address;
using general::memory::distribution::reserved_address;

还有
general::memory::distribution{
    using null_address = address<block::null>;    //null 地址
    using code_address = address<block::code>;    //代码地址
    using sram_address = address<block::sram>;    //sram 地址
    using peripheral_address = address<block::peripheral_area>;    //外设地址
    using FSMC_address = address<block::FSMC>;    //FSMC 地址
    using reserved_address = address<block::reserved_area>;    //保留地址
}
使用时直接, 

    null_address a1 { 0x08000000 };
    code_address a2 { static_cast<code_address>(a1) };
    a1 = 1000;
    code_address a3 { a1 };
    code_address a4 { a3 };
    code_address a5 = a4;
    a5 = a3;
    sram_address a6 { 1545 };
这个code_address a3 { a1 };,我不知道为什么会没问题.
我写的是
template<block other_block_type>
constexpr explicit address(const address<other_block_type>& other) :
    address_value(other.address_value) {
}
这应该出错, 
- 直接初始化：允许使用 explicit 构造函数
- 复制初始化：不允许使用 explicit 构造函数
- 列表初始化：允许使用 explicit 构造函数（C++11+特性）
我都无语. 都写explicit了,还可以隐式转换. 就是脑子有问题.
要是
// 阻止隐式转换
constexpr address(const address&) = delete;

// 允许显式转换（使用static_cast）
template<block other_block_type>
constexpr explicit address(const address<other_block_type>& other) :
    address_value(other.address_value) {
}
这样那就太麻烦了.同类型还他妈要转换?你怎么不去死. 2b
然后这个设计也是很符合项目(我)的设计原则.
对了, 显式转换是为了安全性和可靠性.
但同时不应有太多复杂性.还有冗余.
-- 12.16
还有,我在代码中有意思的地方.
还有这个interval - 数学区间也是符合设计原则
constexpr int_interval alternative_names_area { 0x00000000, 0x000FFFFF };   // 别名区
constexpr int_interval reserved_area1 { 0x00100000, 0x07FFFFFF };   // 保留区域1
这很简单.