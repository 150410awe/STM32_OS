2026.2.26.13.26
去除了全部的标准库. 修了一些小bug. 因为我的扳子今天就要到了, 所以我就编译了一下项目. 测试了全部的文件. 修复编译错误.
编译文件.bin 有5kb. 占 Flash 0.9% (used 4476 bytes from 524288 bytes)
但是 RAM 10.8% (used 14100 bytes from 131072 bytes)
这就不ok了. 主要占用
kernel::memory::empty_memory_queue 6,192 字节 44.1%
kernel::device::GPIO::__GPIO__ 4,032 字节 28.8%
kernel::memory::use_memory 3,076 字节 21.9%
全是 GPIO 系统 和 内存管理系统 
但是没法. 数据结构也改不了. 静态数组也不能不用. 384大小也和适啊, 这改不了
我觉得这个系统最多也就10%. 尽管不能和我的电脑比.
这不是我的问题. 因为其他人和这也差不多.
我优化(不是)了一下项目. 那个就没什么意思了.
可以说的是项目我更看不懂了. 因为我把基础的
interval 基础类型 地址interval 全改了. 地址interval现在是
uint_amx_t 所以我不知道会不会在那个地方出问题. 就是类型转换
当然, 很多我用了 { }, 这个比较严格. 错误可能会少一点
0.00.07 去除了全部的标准库, 测试和优化(不是)了全部的文件, 修复编译错误
已更改 14 个文件, 192 行插入(+), 109 行删除(-)
对了, 我没想到没几下编译就过了. 当然ai是2b,天天失忆这一块. 我不想多说了
-- 13.49
对了,  main.cpp

void setup() {
    using namespace kernel::device::RCC;

    AHB1ENR = AHB1_peripheral_clock::GPIOC;

    GPIOC[0] = output_level::high;
    GPIOC[1] = output_level::low;
    GPIOC[2] = output_level::high;
}

void loop() {
    // 主循环代码
}

int main(void) {
    setup();
    while (1) 
        loop();
    
    return 0;
}

这使得直接就可以点灯.
为了安全性, 和我没事干, 我准备优化一下代码, 尽可能用 {} 防止出问题
我换完了, 当然还有一些. 那个没必要. 比如enum 赋值. 我发现了6个类型转换问题. 
- Line 13: narrowing conversion of '(((int)((kernel::device::GPIO::pin*)this)->kernel::device::GPIO::pin::pin_id) * 2)' from 'int' to 'general::type::u32'
- Line 14: narrowing conversion of '(3 << bit_offset)' from 'int' to 'general::type::u32'
- Line 44: 类似Line 13的警告
- Line 45: 类似Line 14的警告
- Line 59: 类似Line 13的警告
- Line 60: 类似Line 14的警告
这个和我想的问题差不多. 但是也是解决了. 所以就这样了
-- 14.18
0.00.07 小补丁 更多使用列表初始化
2026.2.25.11.36
我完成了基础的库和实现内存块合并了
11.58
我又优化了一下下. memory被改成
struct memory {
        int_interval address_interval;
        memory(int_interval address_interval) : address_interval(address_interval) { }
        memory() = default;
        size_t size() const { return address_interval.end - address_interval.start; }
    };
使用了 int_interval.
优化了内存块合并
size_t freed_size = it->second;
use_memory.erase(it->first);
kernel::memory::memory new_block{{reinterpret_cast<max_int_t>(free_address), static_cast<max_int_t>(reinterpret_cast<max_int_t>(free_address) + freed_size)}};
// 合并空闲块
// 注意 因为是地址是闭区间. it->address_interval.start == new_block.address_interval.end + 1 时, 只用修改 end, size 会自动更新, 因为size是函数
// it->address_interval.end == new_block.address_interval.start - 1 时, 只用修改 start, 不修改 end. 本来就不用修改end
for (auto it = empty_memory_queue.begin(); it != empty_memory_queue.end(); ++it) 
    if (it->address_interval.start == new_block.address_interval.end + 1) {
        new_block.address_interval.end += it->size() + 1;
        empty_memory_queue.erase(it.get_pos());
        break;
    }
    else if (it->address_interval.end == new_block.address_interval.start - 1) {
        new_block.address_interval.start = it->address_interval.start;
        empty_memory_queue.erase(it.get_pos());
        break;
    }
empty_memory_queue.push_back(new_block);
也是大约用2.5h
当然没什么好说的. 
array_list.h array_queue.h array_unordered_map.h array.h
这几个让我心里没底. 因为很有可能有错误.
因为是ai写的, 我不想写.
可以说的是 数据结构是我设计的.
array_list.h
array<T, N> data;   // 实休数据
size_t count = 0;   // 大小,最后一个位置?!...
array<size_t, N> list_table;    // 逻辑结构, 方便便利
general::array_queue<size_t, N> free_queue; // 日常复用
然后就这样. 
0.00.06 基础库, 内存块合并
已更改 14 个文件, 772 行插入(+), 50 行删除(-)
2026.2.24.21.00
经过我的思考后, 我决定先实现内存管理.
内存分布是这样的,
0x2000 0000 - 0x2001 BFFF：SRAM1（112KB，所有 AHB 主控可访问）
0x2001 C000 - 0x2001 FFFF：SRAM2（16KB，所有 AHB 主控可访问）
0x1000 0000 - 0x1000 FFFF：CCM SRAM（64KB，内核耦合存储器，仅 CPU 可访问）
我现在应该只用, 也最急用的就是 基本的增删改查 因为我内核会用. 
还后也没什么了. 因为按一般的想法就是给内存分区
所以先设计好内存分区吧. 我要了解一些东西.
21.20
okk 我现在已经非常解了. 
程序运行时从0x20000000 (SRAM1起始).
那么我就设定相应的内存布局, 我简单一点.
0x20000000 - 某个地方 内核区
内核区 - SRAM2结束为用户区.
内核堆数据可能可以在用户区.
但那样可能不安全对吧?! 没事, 简单点.
我会自己写一个堆内存的增删. 就是 new 与 delete.
我先给内存分个块.
经过我的深思后决定 512 一块
一共384.
占内存0.7%. 还算可以?
emmmmm, 所以写一个内存结构出来
我终于写出来了内存结构和内存的增删. 但是, 我要记录那个地址被使用
这要用哈希表, 还有那个内存没用, 这要用list.
但是这些东西我没写内存管理也没用啊.
后面我只能用数组模拟一个了. 也就是说记录是有限的
我去掉了之前的块定义, 因为那不好实现连续的内存分配.
直接一个
// general::memory::block_SRAM_snippet.start只是临时. 因为内核内存不算
inline static std::list<memory> empty_memory_queue{memory{static_cast<SRAM_address>(general::memory::block_SRAM_snippet.start), SRAM_size}};
硬写, 我想一开始应该都是空. 后面动态增删.
namespace kernel::call {
    using namespace memory;
    inline void* malloc(size_t size) {
        if (size == 0)
            return nullptr;
        
        for (auto it = empty_memory_queue.begin(); it != empty_memory_queue.end(); ++it) 
            if (it->size >= size) {
                void* result = reinterpret_cast<void*>(it->base_address.address_value);
                size_t allocated_size = size;
                
                use_memory.emplace(std::pair{ it->base_address.address_value , allocated_size });
                if (it->size == size) 
                    // 完全匹配，从空闲队列中删除
                    empty_memory_queue.erase(it);
                else {
                    // 分割块，更新剩余部分, 让base_address向高地址方向
                    it->base_address.offset(it->base_address.address_value + size);
                    it->size -= size;
                }

                return result;
            }
        return nullptr;
    }
    inline void free(void* free_address) {
        if (free_address == nullptr)
            return;
        
        auto it = use_memory.find(reinterpret_cast<u32>(free_address));
        if (it == use_memory.end())
            return;
        
        size_t freed_size = it->second;
        use_memory.erase(it);

        empty_memory_queue.push_back(kernel::memory::memory{SRAM_address{reinterpret_cast<u32>(free_address)}, freed_size});
    }
}
use_memory.emplace(it.base_address.address_value, size);use_memory.erase(it);
动态增删记录.
但, 因为后面就是数组了, 所以在内存上不是动态. 这会有内存碎与问题. 但很可能那个时候就因为 数组 满了不让玩了.
乐. 这就是半个内存管理了. 
0.00.05 内存管理增删
已更改 10 个文件, 170 行插入(+), 14 行删除(-)
我不想让他变复杂. 只要实现最最基础的功能就okk了
对了, 我返回和接收的地址是 void* 为什么是 void*?
先说返回. 我 malloc 还要管这是什么什么地址吗? 还要管有没有非法访问吗?
你给我的, 那必须是合法的, 所以我只管用.
在说接收. 用 哈希表 他可以保证你的地址是合法的, 然后 free
不合法直接 return 了
还有, 就是方便. 这个 SRAM_address 写的感觉像我看 rust 的感觉.
就是不太灵活, 类型太强了, 我写的不开心, 也是为了快速开发.
2026.2.24.13.08
我用了一个小时, 完成了时钟使能寄存器.
现在应该可以支持GPIO的设置了. 就只有时钟使能寄存器
其他的  时钟配置寄存器,PLL配置寄存器. 时钟控制寄存器...
全部没写, 点灯不会用到他. 我用宏去掉了
pin& operator=(AF0 af0);
...
这种东西, 因为这个傻逼编译器好像不支持c++20, 我操你奶.只能用宏
__operator_AF__(AF0)
__operator_AF__(AF1)
...
使用起来也是一样简单
    AHB1ENR = AHB1_peripheral_clock::GPIOA;
    // AHB2ENR = AHB1_peripheral_clock::DMA1; error
    AHB3ENR = AHB3_peripheral_clock::FSMC;
但是他现在还没有 释放 的功能,
当然前的架构对RAII支持不太好. 因为都是全局变量. 可以写一个上层的类. 只有对与的引用
然后用RAII释放. 
这样的架构就三层
上层 一个非常简单的类 主要实现RAII.
中层 GPIO数组. 有实体数据.
下层 pin直接与硬件交互.
上层使用时返回中层数据. 中层使用时返回下层数据. 下层与硬件交互.
为什么是返回数据.
因为 GPIO 实现就是这样的.
pin& operator[](size_t index) {
    return pins[index];
}
返回下层pin&.
pin
然后在次
pin& operator=(work_mode mode)
里面与硬件交互.
总的来说比较简单.
0.00.04 时钟使能寄存器 少量支持
已更改 15 个文件, 186 行插入(+), 460 行删除(-)
2026.2.23.17.35
太不容易了, 我终于完成GPIO 的基础写功能. 使用大概是这样
    GPIOA[1] = true;
    GPIO[1][2] = false;
    GPIOD[10] = kernel::device::GPIO::AF15::EVENTOUT;
    GPIOD[10] = kernel::device::GPIO::AF7::USART3;
这行不容易
我写了8个小时.
先实现了 clock_enable h clock_enable_peripheral_clock.h h RCC_config.h h RCC_register_config.h
后面可以使用GPIO. 还写了GPIO寄存器的区间地址, 方便后面检查地址和法性
然后开始实现GPIO struct
一开始想使用模板特化 编译时 计算寄存器地址, 
然后写引脚, 因为我GPIO设计用的是编译时 所以pin也是编译时 我想对每个pin都在编译时计算地址, 但是不行. 
所以只能去掉编译时了, 在开始时计算. 使用
        peripheral_address GPIO_address;
        u8 pin_id;
写值. 非常弱智的
        pin& operator=(work_mode mode);
        pin& operator=(output_type type);
        pin& operator=(pull_up_down pull);
        pin& operator=(output_speed speed);
        pin& operator=(bool ODR_or_IDR);
        pin& operator=(AF0 af0);
        pin& operator=(AF1 af1);
        pin& operator=(AF2 af2);
        pin& operator=(AF3 af3);
        pin& operator=(AF4 af4);
        pin& operator=(AF5 af5);
        pin& operator=(AF6 af6);
        pin& operator=(AF7 af7);
        pin& operator=(AF8 af8);
        pin& operator=(AF9 af9);
        pin& operator=(AF10 af10);
        pin& operator=(AF11 af11);
        pin& operator=(AF12 af12);
        pin& operator=(AF13 af13);
        pin& operator=(AF14 af14);
        pin& operator=(AF15 af15);
但是简单. .cpp文件干到了429行, 都是有很多重复的代码.
重点在怎么实现GPIO[1][2].
GPIO[1]要返回的应该是pin&
所以pin要自己计算, 也是为什么想对每个pin都在编译时计算地址.
那样很简单.
这日记说的感觉没什么. 但是真的耗时. 还干了别的事.
我都他妈的在写代码了. 
我心还是没底.
这还没完. 后面还有检查.
之所以先写GPIO就是因为他重要.
后面方便点灯. 我真的非常无语用标准库写的什么狗屁东西.
这是标准库
// 配置PC13为推挽输出（通常连接LED）
GPIOC->MODER &= ~GPIO_MODER_MODER13;      // 清零
GPIOC->MODER |= GPIO_MODER_MODER13_0;      // 设为01：通用输出模式
GPIOC->OTYPER &= ~GPIO_OTYPER_OT_13;       // 推挽输出
GPIOC->OSPEEDR |= GPIO_OSPEEDER_OSPEEDR13; // 设为高速
GPIOC->PUPDR &= ~GPIO_PUPDR_PUPDR13;       // 无上拉/下拉
// 点亮LED
GPIOC->BSRR = GPIO_BSRR_BS_13;              // 置位（输出高）
// 熄灭LED
GPIOC->BSRR = GPIO_BSRR_BR_13;              // 复位（输出低）
这是我写的
    GPIOC[13] = kernel::device::GPIO::work_mode::alternate_function_push_pull;
    GPIOC[13] = kernel::device::GPIO::output_type::push_pull;
    GPIOC[13] = kernel::device::GPIO::output_speed::very_high_speed;
    GPIOC[13] = kernel::device::GPIO::pull_up_down::no_pull;
    GPIOC[13] = 0x0b1;
    GPIOC[13] = 0x0b0;

这以后,后面就是我的标准库了.
好了. 这就是更新内容了
0.00.03 GPIO 对少量支持
已更改 19 个文件, 1132 行插入(+), 3 行删除(-)
2026.2.22.20.08
我和external_device_memory_distribution.h又斗了一会.
现在完全是编译时了, 主要是更加安全,可读性更强
any int 不可以直接引用
general::device::external_device_memory[external_device_type].start
general::device::external_device_memory[static_cast<general::device::external_device_type>(i)].contains(address_value)
const auto c1cc = general::device::external_device_memory[general::device::external_device_type::null];
emmmmm, 尽管我写的难受, 但是使用还是很好
0.00.02 小补丁, FSMC_device_memory, external_device_memory 完全编译期. 增加了安全性和可读性
已更改 8 个文件, 159 行插入(+), 109 行删除(-)
2026.2.22.17.55
DS:
用你的 gpio_address 去操作寄存器。
你会发现自己设计的类型用起来有多顺手——比如：
cpp
gpio_addr odr { 0x40020014 };
odr = 0x01;  // 点亮 LED
编译器会阻止你把 sram_addr 赋值给 odr，这种安全感在裸机上很珍贵。
...
有感, 不知道为什么想到,emmmmm, 直接看代码
    constexpr max_int_t null_address_value = 0x100000000;// null_address_value - 默认空地址值, 为 null_address 指向的地址值, 一般改不了
    constexpr int_interval null_address_interval {null_address_value,null_address_value};
    // 前向声明, 尽管无法完全 constexpr, 但是一个引用也算是零成本了
    static constexpr std::array<int_interval, static_cast<size_t>(external_device_type::MAX_VAL)> init_external_device_memory();
    static constexpr std::array<int_interval, static_cast<size_t>(FSMC_device_type::MAX_VAL)> init_FSMC_device_memory();
    
    // 使用前向声明的函数初始化
    const inline ...& external_device_memory{ init_external_device_memory() };
    const inline  ...& FSMC_device_memory { init_FSMC_device_memory() };

external_device_memory[static_cast<size_t>(external_device_type::null)] = memory::distribution::null_address_interval;
FSMC_device_memory[static_cast<size_t>(FSMC_device_type::null)] = memory::distribution::null_address_interval;
支持null
struct peripheral_address : address<peripheral_address, block::peripheral_area> {
    constexpr peripheral_address() = default;
    constexpr peripheral_address(const general::device::external_device_type set_device_type) : external_device_type(set_device_type) {
        address_value = general::device::external_device_memory[static_cast<size_t>(external_device_type)].start;
    }
    peripheral_address& operator=(const general::device::external_device_type set_device_type) {
        external_device_type = set_device_type;
        address_value = general::device::external_device_memory[static_cast<size_t>(external_device_type)].start;
        return *this;
    }
    constexpr peripheral_address& operator+=(const peripheral_address set_address) = delete;
    constexpr peripheral_address operator+(const peripheral_address set_address) = delete;
    general::device::external_device_type external_device_type = general::device::external_device_type::null;
    ...
};
struct FSMC_address : address<FSMC_address, block::FSMC> {
    constexpr FSMC_address()  = default;
    constexpr FSMC_address(const general::device::FSMC_device_type set_device_type) : FSMC_device_type(set_device_type) {
        address_value = general::device::FSMC_device_memory[static_cast<size_t>(FSMC_device_type)].start;
    }
    FSMC_address& operator=(const general::device::FSMC_device_type set_device_type ) {
        FSMC_device_type = set_device_type;
        address_value = general::device::FSMC_device_memory[static_cast<size_t>(FSMC_device_type)].start;
        return *this;
    }
    constexpr FSMC_address& operator+=(const FSMC_address set_address) = delete;
    constexpr FSMC_address operator+(const FSMC_address set_address) = delete;
    ....
};

    FSMC_address f1{};
    FSMC_address f2{f1};
    //FSMC_address f3{100}; error
    FSMC_address f4{general::device::FSMC_device_type::FSMC_NAND2};
    FSMC_address f5{general::device::FSMC_device_type::null};

    //f2 = FSMC_address{1000}; error
    //f2 = &aa_value; error
    // 因为general::device::FSMC_device_type 不是 constexpr 所以不可以, 这是编绎器的问题, 不星我的问题
    //constexpr FSMC_address f6{general::device::FSMC_device_type::FSMC_NAND2};

    //f1 += f2; error
    f1 = f2;
    // f1 + f2; error

    peripheral_address p1{};
    peripheral_address p2 = p1;
    // peripheral_address p3{general::device::FSMC_device_type::FSMC_NAND1} error
    peripheral_address p4{general::device::external_device_type::ADC1};
    peripheral_address p5{general::device::external_device_type::null};
    //...
这增加了安全性. 还有我不用记内存了. 直接general::device::external_device_type::....
简单～
对了. null_address 也是原规上不可以修改 address_value
// NULL 不可以修改
    constexpr null_address& operator=(max_int_t set_address) = delete;
    constexpr null_address& operator+=(const max_int_t set_address) = delete;
    constexpr null_address operator+(const max_int_t set_address) const = delete;
    constexpr null_address operator+(const null_address set_address) const = delete;
......
对的.就这样了. 这是一个小补丁
0.00.02 小补丁, 地址类型加强, 增加了安全性和简单性
已更改 8 个文件, 179 行插入(+), 45 行删除(-)
2026.2.22.16.35
我终于写完了外设类型与外设地址, 我使用了 CRTP emmmm,
好吧, 为了安全性,他更复杂了.
还好使用起来比较无脑, 看着对 constexpr 的支持好像也没问题
他可能更安全了, any int 不可以对他 operator=
code_address c112{100};
c112 = 1000; error
max_int_t aa_value = 100;
    aa = &aa_value;
auto aa = a2 + code_address{100};
    auto bb = a2 + aa;
    auto cc = a2 += code_address{10};
    auto dd = aa = code_address{10};
    constexpr code_address c1{1000};
    constexpr code_address c2{c1};
    constexpr auto c3 = c1 + c2;
    constexpr code_address c4 = c3;
    constexpr null_address c13{};
constexpr address_t operator+(const address_t set_address)
constexpr address_t& operator+=(const address_t set_address)
address_t& operator=(max_int_t* set_address)
这使得类型更安全. 但是我心还是没底.
我在想有没有必须写不同类型地址的转换. emmmmm, 后面可能去掉.
因为他有点不安全.
if (!update() || !check_address()) {
    address_value = null_address_value;
    // error...
}
constexpr bool check_address() const {
    return static_cast<const address_t*>(this)->check_address();
}
constexpr bool update() {
    return static_cast<address_t*>(this)->update();
}
这个, 应该是先update()在check_address(), 应该不会有问题.
我为了防止循环引用,拆了address_struct.h 分对应的几个类型的文件.
原则上 struct address 不可以直接写.
这几个类型地址原则上完全不是一会事.
// 检查外部设备内存是否包含该地址
        const auto& external_device_memory = general::device::external_device_memory[static_cast<size_t>(external_device_type)];
        if (!external_device_memory.contains(address_value))
            return false;
看着还不错.
但是 general::device::external_device_memory 不知道为啥不可以加 constexpr . 非常弱智.
0.00.02 外设类型,地址. 地址类型细分,加强
已更改 18 个文件, 693 行插入(+), 523 行删除(-)
2026.2.21.20.21
增加了对 clangd 的支持. 
增加了
general::memory::distribution::address::check_address()
检查地址.
去除了
update_block_type
整合到check_address
有地址块类型检查和该块类型的地址范围检查, 保证地址的合法性, 可以防止地址指向越界和保留区域
--20.59
好拉, 现在这个0.00.01也算干完了.
下面是什么?
好又不好的是这个项目不会有终端和硬盘. 这实现起来会更简单.
可以写
cctype,time,utime,Imn_enum_struct_bit_mask,variadic
emmmmm,我就会个x64,arm汇编我是不会的.
所以我直接封装一下吧.
cctype,time,utime std都有
我直接封装
variadic lmn_enum_struct_bit_mask 我copy一下
okk, 那这std就这样完了.
哎呀这个, cctype,time,utime直接用std的把,我不写了.
variadic lmn_enum_struct_bit_mask copy 过来...
我写屁. variadic 问题太多了. 还是直接用库吧, 我是无语.
我可不造一个va_start出来.
引入 lmn_enum_struct_bit_mask 
--23.22
0.00.02 增加了 general::memory::distribution::address::check_address(), update_block_type 整合到check_address, 引入 lmn_enum_struct_bit_mask
已更改 9 个文件, 312 行插入(+), 89 行删除(-)
妈的我终于配置好了这个clangd 的傻逼格式化, 无语, 怎么地还都不行
2026.2.21.11.45
哦1145...

我当然想学点嵌入式，但是at89c51 和那个2b ide还有那个无聊的课程让我一点都不想学，
说明书我看着想死。我就想可以这样。卖个性能强点，现代的板子，为他定制做个os，我去这太好了，
因为这样我就可以了解这个板子，学习他，还可以为他实现一些功能，那些功能什么定时器，时间，led，
都会用到。这不都是那2b课程会有的吗，还可以是一个os实现的实战。我去，回去我就想着卖一个我喜欢的板子玩，
只要别把我电死了
哦，我为什么要把重构收尾？！我差点就到了我关心的地方。好吧，
我对os的组成也有了个大概了解。尽管我已经忘了太多。但是我知道可能要有内存，
进程，终端，文件，重定位，权限emmmm什么，我知道他们的大概构成和一些函数。。。
emmm好吧，我都忘了。嘿嘿~
嗯~，也可以，这个嵌入式os应该更好玩。
-- 2026.2.19.22.19 日记
所以我找到了更好玩的东西. 我己经写完了内存分布参数和一些基础类型.
还有 address 类型, 我觉得他还不错
还有你发现有一个叫internal的文件夹.
为什么会有他???
因为这个项目(我)的设计原则之一就是 内部复杂外部简单
这个项目(我)的设计原则只有二个
内部复杂外部简单, 代码即文档.
所以我会有一个 type.h 一个类型定义集合.

using namespace general::type;
using general::memory::distribution::null_address;
using general::memory::distribution::code_address;
using general::memory::distribution::sram_address;
using general::memory::distribution::peripheral_address;
using general::memory::distribution::FSMC_address;
using general::memory::distribution::reserved_address;

还有
general::memory::distribution{
    using null_address = address<block::null>;    //null 地址
    using code_address = address<block::code>;    //代码地址
    using sram_address = address<block::sram>;    //sram 地址
    using peripheral_address = address<block::peripheral_area>;    //外设地址
    using FSMC_address = address<block::FSMC>;    //FSMC 地址
    using reserved_address = address<block::reserved_area>;    //保留地址
}
使用时直接, 

    null_address a1 { 0x08000000 };
    code_address a2 { static_cast<code_address>(a1) };
    a1 = 1000;
    code_address a3 { a1 };
    code_address a4 { a3 };
    code_address a5 = a4;
    a5 = a3;
    sram_address a6 { 1545 };
这个code_address a3 { a1 };,我不知道为什么会没问题.
我写的是
template<block other_block_type>
constexpr explicit address(const address<other_block_type>& other) :
    address_value(other.address_value) {
}
这应该出错, 
- 直接初始化：允许使用 explicit 构造函数
- 复制初始化：不允许使用 explicit 构造函数
- 列表初始化：允许使用 explicit 构造函数（C++11+特性）
我都无语. 都写explicit了,还可以隐式转换. 就是脑子有问题.
要是
// 阻止隐式转换
constexpr address(const address&) = delete;

// 允许显式转换（使用static_cast）
template<block other_block_type>
constexpr explicit address(const address<other_block_type>& other) :
    address_value(other.address_value) {
}
这样那就太麻烦了.同类型还他妈要转换?你怎么不去死. 2b
然后这个设计也是很符合项目(我)的设计原则.
对了, 显式转换是为了安全性和可靠性.
但同时不应有太多复杂性.还有冗余.
-- 12.16
还有,我在代码中有意思的地方.
还有这个interval - 数学区间也是符合设计原则
constexpr int_interval alternative_names_area { 0x00000000, 0x000FFFFF };   // 别名区
constexpr int_interval reserved_area1 { 0x00100000, 0x07FFFFFF };   // 保留区域1
这很简单.