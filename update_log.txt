2026.2.22.16.35
我终于写完了外设类型与外设地址, 我使用了 CRTP emmmm,
好吧, 为了安全性,他更复杂了.
还好使用起来比较无脑, 对 constexpr 的支持也没问题
他可能更安全了, any int 不可以对他 operator=
code_address c112{100};
c112 = 1000; error
max_int_t aa_value = 100;
    aa = &aa_value;
auto aa = a2 + code_address{100};
    auto bb = a2 + aa;
    auto cc = a2 += code_address{10};
    auto dd = aa = code_address{10};
    constexpr code_address c1{1000};
    constexpr code_address c2{c1};
    constexpr auto c3 = c1 + c2;
    constexpr code_address c4 = c3;
    constexpr null_address c13{};
constexpr address_t operator+(const address_t set_address)
constexpr address_t& operator+=(const address_t set_address)
address_t& operator=(max_int_t* set_address)
这使得类型更安全. 但是我心还是没底.
我在想有没有必须写不同类型地址的转换. emmmmm, 后面可能去掉.
因为他有点不安全.
if (!update() || !check_address()) {
    address_value = null_address_value;
    // error...
}
constexpr bool check_address() const {
    return static_cast<const address_t*>(this)->check_address();
}
constexpr bool update() {
    return static_cast<address_t*>(this)->update();
}
这个, 应该是先update()在check_address(), 应该不会有问题.
我为了防止循环引用,拆了address_struct.h 分对应的几个类型的文件.
原则上 struct address 不可以直接写.
这几个类型地址原则上完全不是一会事.
// 检查外部设备内存是否包含该地址
        const auto& external_device_memory = general::device::external_device_memory[static_cast<size_t>(external_device_type)];
        if (!external_device_memory.contains(address_value))
            return false;
看着还不错.
但是 general::device::external_device_memory 不知道为啥不可以加 constexpr . 非常弱智.
0.00.02 外设类型,地址. 地址类型细分,加强
2026.2.21.20.21
增加了对 clangd 的支持. 
增加了
general::memory::distribution::address::check_address()
检查地址.
去除了
update_block_type
整合到check_address
有地址块类型检查和该块类型的地址范围检查, 保证地址的合法性, 可以防止地址指向越界和保留区域
--20.59
好拉, 现在这个0.00.01也算干完了.
下面是什么?
好又不好的是这个项目不会有终端和硬盘. 这实现起来会更简单.
可以写
cctype,time,utime,Imn_enum_struct_bit_mask,variadic
emmmmm,我就会个x64,arm汇编我是不会的.
所以我直接封装一下吧.
cctype,time,utime std都有
我直接封装
variadic lmn_enum_struct_bit_mask 我copy一下
okk, 那这std就这样完了.
哎呀这个, cctype,time,utime直接用std的把,我不写了.
variadic lmn_enum_struct_bit_mask copy 过来...
我写屁. variadic 问题太多了. 还是直接用库吧, 我是无语.
我可不造一个va_start出来.
引入 lmn_enum_struct_bit_mask 
--23.22
0.00.02 增加了 general::memory::distribution::address::check_address(), update_block_type 整合到check_address, 引入 lmn_enum_struct_bit_mask
已更改 9 个文件, 312 行插入(+), 89 行删除(-)
妈的我终于配置好了这个clangd 的傻逼格式化, 无语, 怎么地还都不行
2026.2.21.11.45
哦1145...

我当然想学点嵌入式，但是at89c51 和那个2b ide还有那个无聊的课程让我一点都不想学，
说明书我看着想死。我就想可以这样。卖个性能强点，现代的板子，为他定制做个os，我去这太好了，
因为这样我就可以了解这个板子，学习他，还可以为他实现一些功能，那些功能什么定时器，时间，led，
都会用到。这不都是那2b课程会有的吗，还可以是一个os实现的实战。我去，回去我就想着卖一个我喜欢的板子玩，
只要别把我电死了
哦，我为什么要把重构收尾？！我差点就到了我关心的地方。好吧，
我对os的组成也有了个大概了解。尽管我已经忘了太多。但是我知道可能要有内存，
进程，终端，文件，重定位，权限emmmm什么，我知道他们的大概构成和一些函数。。。
emmm好吧，我都忘了。嘿嘿~
嗯~，也可以，这个嵌入式os应该更好玩。
-- 2026.2.19.22.19 日记
所以我找到了更好玩的东西. 我己经写完了内存分布参数和一些基础类型.
还有 address 类型, 我觉得他还不错
还有你发现有一个叫internal的文件夹.
为什么会有他???
因为这个项目(我)的设计原则之一就是 内部复杂外部简单
这个项目(我)的设计原则只有二个
内部复杂外部简单, 代码即文档.
所以我会有一个 type.h 一个类型定义集合.

using namespace general::type;
using general::memory::distribution::null_address;
using general::memory::distribution::code_address;
using general::memory::distribution::sram_address;
using general::memory::distribution::peripheral_address;
using general::memory::distribution::FSMC_address;
using general::memory::distribution::reserved_address;

还有
general::memory::distribution{
    using null_address = address<block::null>;    //null 地址
    using code_address = address<block::code>;    //代码地址
    using sram_address = address<block::sram>;    //sram 地址
    using peripheral_address = address<block::peripheral_area>;    //外设地址
    using FSMC_address = address<block::FSMC>;    //FSMC 地址
    using reserved_address = address<block::reserved_area>;    //保留地址
}
使用时直接, 

    null_address a1 { 0x08000000 };
    code_address a2 { static_cast<code_address>(a1) };
    a1 = 1000;
    code_address a3 { a1 };
    code_address a4 { a3 };
    code_address a5 = a4;
    a5 = a3;
    sram_address a6 { 1545 };
这个code_address a3 { a1 };,我不知道为什么会没问题.
我写的是
template<block other_block_type>
constexpr explicit address(const address<other_block_type>& other) :
    address_value(other.address_value) {
}
这应该出错, 
- 直接初始化：允许使用 explicit 构造函数
- 复制初始化：不允许使用 explicit 构造函数
- 列表初始化：允许使用 explicit 构造函数（C++11+特性）
我都无语. 都写explicit了,还可以隐式转换. 就是脑子有问题.
要是
// 阻止隐式转换
constexpr address(const address&) = delete;

// 允许显式转换（使用static_cast）
template<block other_block_type>
constexpr explicit address(const address<other_block_type>& other) :
    address_value(other.address_value) {
}
这样那就太麻烦了.同类型还他妈要转换?你怎么不去死. 2b
然后这个设计也是很符合项目(我)的设计原则.
对了, 显式转换是为了安全性和可靠性.
但同时不应有太多复杂性.还有冗余.
-- 12.16
还有,我在代码中有意思的地方.
还有这个interval - 数学区间也是符合设计原则
constexpr int_interval alternative_names_area { 0x00000000, 0x000FFFFF };   // 别名区
constexpr int_interval reserved_area1 { 0x00100000, 0x07FFFFFF };   // 保留区域1
这很简单.